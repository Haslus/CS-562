#version 430

// Phong tess patch data
struct PhongPatch
{
 float valueIJ;
 float valueJK;
 float valueIK;
};

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

const float uTessAlpha = 1.0f;     

layout(triangles, fractional_odd_spacing, ccw) in;

in vec3 tes_Normal[];
in vec3 tes_Tangent[];
in vec3 tes_Bitangent[];
in vec2 tes_TexCoords[];
in PhongPatch P_Patch[];

out vec3 finalNormal;
out vec3 finalTangent;
out vec3 finalBitangent;
out vec2 finalTexCoords;
out vec3 finalPos;

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz
#define tc1 gl_TessCoord

void main()
{
	//squared tesscoords 
	vec3 tc2 = tc1*tc1;

	//compute texcoords and normal
	finalTexCoords = gl_TessCoord[0] * tes_TexCoords[0]
	+ gl_TessCoord[1] * tes_TexCoords[1] + gl_TessCoord[2] * tes_TexCoords[2];

	finalNormal = gl_TessCoord[0] * tes_Normal[0]
	+ gl_TessCoord[1] * tes_Normal[1] + gl_TessCoord[2] * tes_Normal[2];

	finalTangent = gl_TessCoord[0] * tes_Tangent[0]
	+ gl_TessCoord[1] * tes_Tangent[1] + gl_TessCoord[2] * tes_Tangent[2];

	finalBitangent = gl_TessCoord[0] * tes_Bitangent[0]
	+ gl_TessCoord[1] * tes_Bitangent[1] + gl_TessCoord[2] * tes_Bitangent[2];

	vec3 barPos = gl_TessCoord[0] * Pi + gl_TessCoord[1] * Pj + gl_TessCoord[2] * Pk;

	vec3 termIJ = vec3(P_Patch[0].valueIJ,P_Patch[1].valueIJ,P_Patch[2].valueIJ);
	vec3 termJK = vec3(P_Patch[0].valueJK,P_Patch[1].valueJK,P_Patch[2].valueJK);
	vec3 termIK = vec3(P_Patch[0].valueIK,P_Patch[1].valueIK,P_Patch[2].valueIK);

	vec3 phongPos = tc2[0]*Pi + tc2[1]*Pj + tc2[2]*Pk + tc1[0] * tc1[1] * termIJ +
	tc1[1] * tc1[2] * termJK + tc1[2] * tc1[0] * termIK;

	vec3 Pos = (1.0 - uTessAlpha) * barPos + uTessAlpha * phongPos;
	gl_Position =  projection * view * model * vec4(Pos,1.0);

	finalPos = Pos;

}