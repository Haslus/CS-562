#version 430

// Phong patch data
struct PhongPatch
{
 float valueIJ;
 float valueJK;
 float valueIK;
};

// tessellation levels
uniform float uTessLevels;

uniform bool adaptiveTesellation;
uniform bool LOD;
uniform float LOD_distance = 10.0;
uniform int LOD_pow = 10;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
 
 
layout(vertices=3) out;

in vec3 tcs_Normal[];
in vec3 tcs_Tangent[];
in vec3 tcs_Bitangent[];
in vec2 tcs_TexCoords[];

out vec3 tes_Normal[3];
out vec3 tes_Tangent[3];
out vec3 tes_Bitangent[3];
out vec2 tes_TexCoords[3];
out PhongPatch P_Patch[3];

out float tes_refinementDepth[3];

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz

float PIi(int i, vec3 p)
{
	//vec3 q_minus_p = q - gl_in[i].gl_Position.xyz;
	return p[gl_InvocationID] - dot(p - gl_in[i].gl_Position.xyz, tcs_Normal[i]) * tcs_Normal[i][gl_InvocationID];

}

float calculate_factorLOD(vec3 camPos, vec3 p, vec3 q)
{
	float distance = length(camPos.xyz - ((p + q) / 2.0));
	float factor = 1.0 / max(1.0, (distance / LOD_distance));
	factor = pow(factor,LOD_pow);

	return factor;
}

float calculate_refinementDepth(vec3 normal, vec3 p, vec3 camPos)
{
	return 1 - abs(dot( normal , normalize(camPos - p) ) );
}

void main()
{
	//Store data for TES
	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	tes_Normal[gl_InvocationID] = tcs_Normal[gl_InvocationID];
	tes_TexCoords[gl_InvocationID] = tcs_TexCoords[gl_InvocationID];
	tes_Tangent[gl_InvocationID] = tcs_Tangent[gl_InvocationID];
	tes_Bitangent[gl_InvocationID] = tcs_Bitangent[gl_InvocationID];

	//Compute Patch data for TES
	P_Patch[gl_InvocationID].valueIJ = PIi(0, Pj) + PIi(1,Pi);
	P_Patch[gl_InvocationID].valueJK = PIi(1, Pk) + PIi(2,Pj);
	P_Patch[gl_InvocationID].valueIK = PIi(2, Pi) + PIi(0,Pk);

	//Tesselate
	//If adpative Tessellation is enabled
	if(adaptiveTesellation == true)
	{
		vec4 camPos = inverse(view * model) * vec4(0,0,0,1);

		const int edges[6] = {1,2,0,2,0,1};
		int firstIdx = edges[gl_InvocationID * 2];
		int secondIdx = edges[gl_InvocationID * 2 + 1];

		float dI = calculate_refinementDepth(tcs_Normal[0],Pi,camPos.xyz);
		float dJ = calculate_refinementDepth(tcs_Normal[1],Pj,camPos.xyz);
		float dK = calculate_refinementDepth(tcs_Normal[2],Pk,camPos.xyz);

		float d[3] = {dI,dJ,dK};
		tes_refinementDepth[gl_InvocationID] = d[gl_InvocationID];

		

		//If level of detail is enabled
		if(LOD == true)
		{

			float factor = calculate_factorLOD(camPos.xyz, gl_in[firstIdx].gl_Position.xyz, gl_in[secondIdx].gl_Position.xyz);

			//We only need it once
			if(gl_InvocationID == 0)
			{
				float distance_average = length(camPos.xyz - ((Pi + Pj + Pk) / 3.0));
				float factor_average = 1.0 / max(1.0, (distance_average / LOD_distance));
				factor_average = pow(factor_average,LOD_pow);
				gl_TessLevelInner[0] = factor_average * uTessLevels * (dI + dJ + dK) / 3.0;
			}

			gl_TessLevelOuter[gl_InvocationID] = factor * uTessLevels * (d[firstIdx] + d[secondIdx]) / 2.0;

			
		}
		else
		{
			gl_TessLevelOuter[gl_InvocationID] = uTessLevels * (d[firstIdx] + d[secondIdx]) / 2.0;
			gl_TessLevelInner[0] = uTessLevels * (dI + dJ + dK) / 3.0;
		}


		
		
		
	}

	else
	{
		gl_TessLevelOuter[gl_InvocationID] = uTessLevels;
		gl_TessLevelInner[0] = uTessLevels;
	}
	

}