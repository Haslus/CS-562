#version 430

// Phong tess patch data
struct PhongPatch
{
 float valueIJ;
 float valueJK;
 float valueIK;
};

// tessellation levels
uniform float uTessLevels;

uniform bool adaptiveTesellation;
uniform bool LOD;
uniform float distance_LOD = 5.0;
uniform float LOD_pow = 3.0;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
 
 
layout(vertices=3) out;

in vec3 tcs_Normal[];
in vec3 tcs_Tangent[];
in vec3 tcs_Bitangent[];
in vec2 tcs_TexCoords[];

out vec3 tes_Normal[3];
out vec3 tes_Tangent[3];
out vec3 tes_Bitangent[3];
out vec2 tes_TexCoords[3];
out PhongPatch P_Patch[3];

out float tes_refinementDepth[3];

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz

float PIi(int i, vec3 q)
{
	vec3 q_minus_p = q - gl_in[i].gl_Position.xyz;
	return q[gl_InvocationID] - dot(q_minus_p, tcs_Normal[i]) 
		* tcs_Normal[i][gl_InvocationID];

}


void main()
{
	//get data
	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	tes_Normal[gl_InvocationID] = tcs_Normal[gl_InvocationID];
	tes_TexCoords[gl_InvocationID] = tcs_TexCoords[gl_InvocationID];
	tes_Tangent[gl_InvocationID] = tcs_Tangent[gl_InvocationID];
	tes_Bitangent[gl_InvocationID] = tcs_Bitangent[gl_InvocationID];

	//compute patch data
	P_Patch[gl_InvocationID].valueIJ = PIi(0, Pj) + PIi(1,Pi);
	P_Patch[gl_InvocationID].valueJK = PIi(1, Pk) + PIi(2,Pj);
	P_Patch[gl_InvocationID].valueIK = PIi(2, Pi) + PIi(0,Pk);

	//tesselate

	if(adaptiveTesellation == true)
	{
		vec4 camPos = inverse(view * model) * vec4(0,0,0,1);

		float dI = (1 - abs(dot( tcs_Normal[0] , normalize(camPos.xyz - Pi) )));
		float dJ = (1 - abs(dot( tcs_Normal[1] , normalize(camPos.xyz - Pj) )));
		float dK = (1 - abs(dot( tcs_Normal[2] , normalize(camPos.xyz - Pk) )));

		float d[3] = {dI,dJ,dK};


		float factor = 1.0;

		
		
		
		if(gl_InvocationID == 0)
		{
			float factor_average = 1.0;

			if(LOD == true)
			{
				float distance = length(camPos.xyz - ((Pj + Pk) / 2.0));
				factor = 1.0 / max(1.0, (distance / distance_LOD));
				factor = pow(factor,LOD_pow);

				float distance_average = length(camPos.xyz - ((Pi + Pj + Pk) / 3.0));
				factor_average = 1.0 / max(1.0, (distance_average / distance_LOD));
				factor_average = pow(factor_average,LOD_pow);
			}

			gl_TessLevelOuter[gl_InvocationID] = factor * uTessLevels * (dJ + dK) / 2.0;	
			gl_TessLevelInner[0] = factor_average * uTessLevels * (dI + dJ + dK) / 3.0;

			tes_refinementDepth[gl_InvocationID] = factor;
		}
		else if(gl_InvocationID == 1)
		{
			if(LOD == true)
			{
				float distance = length(camPos.xyz - ((Pi + Pk) / 2.0));
				factor = 1.0 / max(1.0, (distance / distance_LOD));
				factor = pow(factor,LOD_pow);

			}
			gl_TessLevelOuter[gl_InvocationID] = factor * uTessLevels * (dI + dK) / 2.0;	
			tes_refinementDepth[gl_InvocationID] = factor;
		}
		else
		{
			if(LOD == true)
			{
				float distance = length(camPos.xyz - ((Pj + Pi) / 2.0));
				factor = 1.0 / max(1.0, (distance / distance_LOD));
				factor = pow(factor,LOD_pow);

			}
			gl_TessLevelOuter[gl_InvocationID] = factor * uTessLevels * (dJ + dI) / 2.0;
			tes_refinementDepth[gl_InvocationID] = factor;
		}

		
		
	}

	else
	{
		gl_TessLevelOuter[gl_InvocationID] = uTessLevels;
		gl_TessLevelInner[0] = uTessLevels;
	}
	

}