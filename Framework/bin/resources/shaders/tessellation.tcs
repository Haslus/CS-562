#version 430

// Phong tess patch data
struct PhongPatch
{
 float valueIJ;
 float valueJK;
 float valueIK;
};

// tessellation levels
uniform float uTessLevels;

uniform bool adaptiveTesellation;
uniform vec3 camPos;
 
 
layout(vertices=3) out;

in vec3 tcs_Normal[];
in vec3 tcs_Tangent[];
in vec3 tcs_Bitangent[];
in vec2 tcs_TexCoords[];

out vec3 tes_Normal[3];
out vec3 tes_Tangent[3];
out vec3 tes_Bitangent[3];
out vec2 tes_TexCoords[3];
out PhongPatch P_Patch[3];

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz

float PIi(int i, vec3 q)
{
	vec3 q_minus_p = q - gl_in[i].gl_Position.xyz;
	return q[gl_InvocationID] - dot(q_minus_p, tcs_Normal[i]) 
		* tcs_Normal[i][gl_InvocationID];

}


void main()
{
	//get data
	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	tes_Normal[gl_InvocationID] = tcs_Normal[gl_InvocationID];
	tes_TexCoords[gl_InvocationID] = tcs_TexCoords[gl_InvocationID];
	tes_Tangent[gl_InvocationID] = tcs_Tangent[gl_InvocationID];
	tes_Bitangent[gl_InvocationID] = tcs_Bitangent[gl_InvocationID];

	//compute patch data
	P_Patch[gl_InvocationID].valueIJ = PIi(0, Pj) + PIi(1,Pi);
	P_Patch[gl_InvocationID].valueJK = PIi(1, Pk) + PIi(2,Pj);
	P_Patch[gl_InvocationID].valueIK = PIi(2, Pi) + PIi(0,Pk);

	//tesselate

	if(adaptiveTesellation == true)
	{
		float dI = (1 - length(tcs_Normal[0] * (camPos - Pi) / length(camPos - Pi)) ) * uTessLevels;
		float dJ = (1 - length(tcs_Normal[1] * (camPos - Pj) / length(camPos - Pj)) ) * uTessLevels;
		float dK = (1 - length(tcs_Normal[2] * (camPos - Pk) / length(camPos - Pk)) ) * uTessLevels;


		gl_TessLevelOuter[0] = (dJ + dK)/2.0;		
		gl_TessLevelOuter[1] = (dI + dK)/2.0;	
		gl_TessLevelOuter[2] = (dJ + dI)/2.0;	
		gl_TessLevelInner[0] = (dI + dJ + dK) / 3.0;
	}

	else
	{
		gl_TessLevelOuter[gl_InvocationID] = uTessLevels;
		gl_TessLevelInner[0] = uTessLevels;
	}
	

}