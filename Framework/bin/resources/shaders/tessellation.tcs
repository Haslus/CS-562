#version 430

// Phong tess patch data
struct PhongPatch
{
 float valueIJ;
 float valueJK;
 float valueIK;
};

// tessellation levels
const float uTessLevels = 1.0f;
 
layout(vertices=3) out;

in vec3 tcs_Normal[];
in vec3 tcs_Tangent[];
in vec3 tcs_Bitangent[];
in vec2 tcs_TexCoords[];

out vec3 tes_Normal[3];
out vec3 tes_Tangent[3];
out vec3 tes_Bitangent[3];
out vec2 tes_TexCoords[3];
out PhongPatch P_Patch[3];

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz

float PIi(int i, vec3 q)
{
	vec3 q_minus_p = q - gl_in[i].gl_Position.xyz;
	return q[gl_InvocationID] - dot(q_minus_p, tcs_Normal[i]) 
		* tcs_Normal[i][gl_InvocationID];

}


void main()
{
	//get data
	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	tes_Normal[gl_InvocationID] = tcs_Normal[gl_InvocationID];
	tes_TexCoords[gl_InvocationID] = tcs_TexCoords[gl_InvocationID];
	tes_Tangent[gl_InvocationID] = tcs_Tangent[gl_InvocationID];
	tes_Bitangent[gl_InvocationID] = tcs_Bitangent[gl_InvocationID];

	//compute patch data
	P_Patch[gl_InvocationID].valueIJ = PIi(0, Pj) + PIi(1,Pi);
	P_Patch[gl_InvocationID].valueJK = PIi(1, Pk) + PIi(2,Pj);
	P_Patch[gl_InvocationID].valueIK = PIi(2, Pi) + PIi(0,Pk);

	//tesselate

	gl_TessLevelOuter[gl_InvocationID] = uTessLevels;
	gl_TessLevelInner[0] = uTessLevels;

}